# .github/workflows/show-release-commits.yml
name: Show release commits
on:
  create:
    tags: true

jobs:
  show_release_commits:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: List commits between tags in same series
        run: |
          set -euo pipefail

          NEW_TAG="${GITHUB_REF#refs/tags/}"
          echo "New tag detected: $NEW_TAG"

          # Dopasuj dynamiczny prefix serii releasu (np. core-2025.0., core-1018.)
          if [[ "$NEW_TAG" =~ ^(core-[0-9]+\.[0-9]+\.) ]]; then
            SERIES_PREFIX="${BASH_REMATCH[1]}"
            echo "Dopasowano prefix serii: $SERIES_PREFIX"
          else
            echo "Tag $NEW_TAG nie pasuje do oczekiwanego wzorca. Przerywam."
            exit 1
          fi

          echo "Detected series prefix: $SERIES_PREFIX"

          # Znajdź wszystkie tagi w tej samej serii, posortuj rosnąco
          mapfile -t SERIES_TAGS < <(git tag --list "${SERIES_PREFIX}*" | sort -V)

          # Znajdź indeks bieżącego taga
          PREVIOUS_TAG=""
          for i in "${!SERIES_TAGS[@]}"; do
            if [[ "${SERIES_TAGS[$i]}" == "$NEW_TAG" ]]; then
              if (( i > 0 )); then
                PREVIOUS_TAG="${SERIES_TAGS[$((i - 1))]}"
              fi
              break
            fi
          done

          if [[ -z "$PREVIOUS_TAG" ]]; then
            echo "Nie znaleziono poprzedniego taga w tej serii. Nie wypisuję commitów."
            exit 0
          fi

          echo "Commits between $PREVIOUS_TAG and $NEW_TAG:"
          git log --pretty=format:'%h %s' "$PREVIOUS_TAG..$NEW_TAG"
